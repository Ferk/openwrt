From c283ae57d1641af345dd9346bd0abb63cbcc73bf Mon Sep 17 00:00:00 2001
From: Josh Wu <josh.wu@atmel.com>
Date: Thu, 21 Mar 2013 18:32:30 +0800
Subject: [PATCH 316/319] mtd: at91: atmel_nand: for PMECC, add code to check
 the ONFI parameter ECC requirement.

This patch will check NAND flash's ecc minimum requirement in ONFI parameter.

1. if pmecc-cap, pmecc-sector-size is set in dts. then use it. Driver will
   print out a WARNING if the values are different from ONFI parameters.
2. if pmecc-cap, pmecc-sector-size is not set in dts, then use the value
   from ONFI parameters.
    * If ONFI ECC parameters are in ONFI extended parameter page, since we are
      not support it, so assume the minimum ecc requirement is 2 bits in 512
      bytes.
    * For non-ONFI support nand flash, also assume the minimum ecc requirement is
      2 bits in 512 bytes.

Signed-off-by: Josh Wu <josh.wu@atmel.com>
---
 drivers/mtd/nand/atmel_nand.c |  111 ++++++++++++++++++++++++++++-------------
 1 file changed, 77 insertions(+), 34 deletions(-)

diff --git a/drivers/mtd/nand/atmel_nand.c b/drivers/mtd/nand/atmel_nand.c
index d79645a..5e38a52 100644
--- a/drivers/mtd/nand/atmel_nand.c
+++ b/drivers/mtd/nand/atmel_nand.c
@@ -952,42 +952,82 @@ static void atmel_pmecc_core_init(struct mtd_info *mtd)
 	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);
 }
 
-static int pmecc_choose_ecc_bits(int pre_ecc_bits, struct nand_chip *nand_chip)
+/*
+ * Get ECC requirement in ONFI parameters, returns -1 if ONFI
+ * parameters is not supported.
+ * return 0 if success to get the ECC requirement.
+ */
+static int get_onfi_ecc_param(struct nand_chip *chip,
+		int *ecc_bits, int *sector_size)
 {
-	int ecc_bits = pre_ecc_bits;
+	*ecc_bits = *sector_size = 0;
 
-	if (nand_chip->onfi_version) {
-		pr_info("ONFI params, minimum required ECC: %d\n",
-				nand_chip->onfi_params.ecc_bits);
-		if (nand_chip->onfi_params.ecc_bits < ecc_bits)
-			ecc_bits = nand_chip->onfi_params.ecc_bits;
-	} else {
-		/* For non-ONFI support nand flash, we assume the software
-		 * ecc can work. That means the ecc_bits = 1.
+	if (chip->onfi_params.ecc_bits == 0xff)
+		/* TODO: the sector_size and ecc_bits need to be find in
+		 * extended ecc parameter, currently we don't support it.
 		 */
-		ecc_bits = 1;
-		pr_info("non-ONFI supported nand flash, assume minimum required ECC: 1\n");
+		return -1;
+
+	*ecc_bits = chip->onfi_params.ecc_bits;
+
+	/* The default sector size (ecc codeword size) is 512 */
+	*sector_size = 512;
+
+	return 0;
+}
+
+/*
+ * Get ecc requirement from ONFI parameters ecc requirement.
+ * If pmecc-cap, pmecc-sector-size in DTS are not specified, this function
+ * will set them according to ONFI ecc requirement. Otherwise, use the
+ * value in DTS file.
+ * return 0 if success. otherwise return error code.
+ */
+static int pmecc_choose_ecc(struct atmel_nand_host *host,
+		int *cap, int *sector_size)
+{
+	/* Get ECC requirement from ONFI parameters */
+	*cap = *sector_size = 0;
+	if (host->nand_chip.onfi_version) {
+		if (!get_onfi_ecc_param(&host->nand_chip, cap, sector_size))
+			dev_info(host->dev, "ONFI params, minimum required ECC: %d bits in %d bytes\n",
+				*cap, *sector_size);
+		else
+			dev_info(host->dev, "NAND chip ECC reqirement is in Extended ONFI parameter, we don't support yet.\n");
+	} else {
+		dev_info(host->dev, "NAND chip is not ONFI compliant, assume ecc_bits is 2 in 512 bytes");
+	}
+	if (*cap == 0 && *sector_size == 0) {
+		*cap = 2;
+		*sector_size = 512;
 	}
 
-	if ((ecc_bits != 2) && (ecc_bits != 4) && (ecc_bits != 8) && (ecc_bits != 12) &&
-	    (ecc_bits != 24)) {
+	/* If dts file doesn't specify then use the one in ONFI parameters */
+	if (host->pmecc_corr_cap == 0) {
 		/* use the most fitable ecc bits (the near bigger one ) */
-		if (ecc_bits < 2)
-			return 2;
-		else if (ecc_bits < 4)
-			return 4;
-		else if (ecc_bits < 8)
-			return 8;
-		else if (ecc_bits < 12)
-			return 12;
-		else if (ecc_bits < 24)
-			return 24;
+		if (*cap <= 2)
+			host->pmecc_corr_cap = 2;
+		else if (*cap <= 4)
+			host->pmecc_corr_cap = 4;
+		else if (*cap < 8)
+			host->pmecc_corr_cap = 8;
+		else if (*cap < 12)
+			host->pmecc_corr_cap = 12;
+		else if (*cap < 24)
+			host->pmecc_corr_cap = 24;
 		else
-			/* not support by our pmecc hw */
-			return pre_ecc_bits;
-	} else {
-		return ecc_bits;
+			return -EINVAL;
+	}
+	if (host->pmecc_sector_size == 0) {
+		/* use the most fitable sector size (the near smaller one ) */
+		if (*sector_size >= 1024)
+			host->pmecc_sector_size = 1024;
+		else if (*sector_size >= 512)
+			host->pmecc_sector_size = 512;
+		else
+			return -EINVAL;
 	}
+	return 0;
 }
 
 static int __init atmel_pmecc_nand_init_params(struct platform_device *pdev,
@@ -998,14 +1038,17 @@ static int __init atmel_pmecc_nand_init_params(struct platform_device *pdev,
 	struct resource *regs, *regs_pmerr, *regs_rom;
 	int cap, sector_size, err_no;
 
-	if (host->pmecc_corr_cap == 0 || host->pmecc_sector_size == 0) {
-		/* Not found in dts, then set according to ONFI parameters */
-		cap = pmecc_choose_ecc_bits(host->pmecc_corr_cap, nand_chip);
-		host->pmecc_corr_cap = cap;
-	} else {
-		cap = host->pmecc_corr_cap;
+	err_no = pmecc_choose_ecc(host, &cap, &sector_size);
+	if (err_no) {
+		dev_err(host->dev, "The NAND flash's ECC requirement are not support!");
+		return err_no;
 	}
 
+	if (cap != host->pmecc_corr_cap ||
+			sector_size != host->pmecc_sector_size)
+		dev_info(host->dev, "WARNING: Be Caution! Using different PMECC parameters from Nand ONFI ECC reqirement.\n");
+
+	cap = host->pmecc_corr_cap;
 	sector_size = host->pmecc_sector_size;
 	host->pmecc_lookup_table_offset = (sector_size == 512) ?
 			host->pmecc_lookup_table_offset_512 :
-- 
1.7.10.4

