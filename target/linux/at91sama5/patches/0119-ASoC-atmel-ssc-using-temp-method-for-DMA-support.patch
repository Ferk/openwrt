From 5bc2e8734caa7247a0801e9cc0ccc7fb02ede7f1 Mon Sep 17 00:00:00 2001
From: Bo Shen <voice.shen@atmel.com>
Date: Thu, 15 Nov 2012 16:18:31 +0800
Subject: [PATCH 119/319] ASoC: atmel-ssc: using temp method for DMA support

Signed-off-by: Bo Shen <voice.shen@atmel.com>
---
 drivers/misc/atmel-ssc.c |   74 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 74 insertions(+)

diff --git a/drivers/misc/atmel-ssc.c b/drivers/misc/atmel-ssc.c
index 422f0c4..4b977a2 100644
--- a/drivers/misc/atmel-ssc.c
+++ b/drivers/misc/atmel-ssc.c
@@ -19,7 +19,9 @@
 #include <linux/module.h>
 
 #include <linux/of.h>
+#include <linux/of_device.h>
 #include <linux/pinctrl/consumer.h>
+#include <linux/platform_data/dma-atmel.h>
 
 /* Serialize access to ssc_list and user count */
 static DEFINE_SPINLOCK(user_lock);
@@ -127,12 +129,66 @@ static inline const struct atmel_ssc_platform_data * __init
 		platform_get_device_id(pdev)->driver_data;
 }
 
+static int atmel_dma_of_init(struct device_node *np,
+                            struct at_dma_slave *atslave)
+{
+       struct of_phandle_args  dma_spec;
+       struct device_node      *dmac_np;
+       struct platform_device  *dmac_pdev;
+       const __be32            *nbcells;
+       int                     ret;
+
+       ret = of_parse_phandle_with_args(np, "dma", "#dma-cells", 0, &dma_spec);
+       if (ret || !dma_spec.np) {
+               pr_err("%s: can't parse dma property (%d)\n", np->full_name, ret);
+               goto err0;
+       }
+       dmac_np = dma_spec.np;
+
+       /* check property format */
+       nbcells = of_get_property(dmac_np, "#dma-cells", NULL);
+       if (!nbcells) {
+               pr_err("%s: #dma-cells property is required\n", np->full_name);
+               ret = -EINVAL;
+               goto err1;
+       }
+
+       if (dma_spec.args_count != be32_to_cpup(nbcells)
+               || dma_spec.args_count != 1) {
+               pr_err("%s: wrong #dma-cells for %s\n",
+                       np->full_name, dmac_np->full_name);
+               ret = -EINVAL;
+               goto err1;
+       }
+
+       /* retreive DMA controller information */
+       dmac_pdev = of_find_device_by_node(dmac_np);
+       if (!dmac_pdev) {
+               pr_err("%s: unable to find pdev from DMA controller\n",
+                       dmac_np->full_name);
+               ret = -EINVAL;
+               goto err1;
+       }
+
+       /* now fill in the at_dma_slave structure */
+       atslave->dma_dev = &dmac_pdev->dev;
+       atslave->cfg = dma_spec.args[0];
+
+err1:
+       of_node_put(dma_spec.np);
+err0:
+       pr_debug("%s exited with status %d\n", __func__, ret);
+       return ret;
+}
+
 static int ssc_probe(struct platform_device *pdev)
 {
 	struct resource *regs;
 	struct ssc_device *ssc;
 	const struct atmel_ssc_platform_data *plat_dat;
 	struct pinctrl *pinctrl;
+	struct at_dma_slave *atslave;
+	struct device_node *np = pdev->dev.of_node;
 
 	pinctrl = devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(pinctrl)) {
@@ -153,6 +209,24 @@ static int ssc_probe(struct platform_device *pdev)
 		return -ENODEV;
 	ssc->pdata = (struct atmel_ssc_platform_data *)plat_dat;
 
+	if (plat_dat->use_dma) {
+		atslave = devm_kzalloc(&pdev->dev, sizeof(struct at_dma_slave),
+				GFP_KERNEL);
+		if (!atslave) {
+			dev_err(&pdev->dev, "failed alloc memory for dma\n");
+			devm_kfree(&pdev->dev, atslave);
+			return -ENOMEM;
+	       }
+
+		if (atmel_dma_of_init(np, atslave)) {
+			dev_err(&pdev->dev, "could not find DMA parameters\n");
+			devm_kfree(&pdev->dev, atslave);
+			return -EINVAL;
+		}
+
+		pdev->dev.platform_data = atslave;
+	}
+
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs) {
 		dev_dbg(&pdev->dev, "no mmio resource defined\n");
-- 
1.7.10.4

