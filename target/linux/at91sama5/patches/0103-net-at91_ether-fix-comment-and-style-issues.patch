From e347673e78635e9f327bf2a7c53ce0055ccab057 Mon Sep 17 00:00:00 2001
From: Joachim Eastwood <manabian@gmail.com>
Date: Wed, 7 Nov 2012 08:14:57 +0000
Subject: [PATCH 103/319] net/at91_ether: fix comment and style issues

Signed-off-by: Joachim Eastwood <manabian@gmail.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
---
 drivers/net/ethernet/cadence/at91_ether.c |  111 +++++++++++++----------------
 1 file changed, 51 insertions(+), 60 deletions(-)

diff --git a/drivers/net/ethernet/cadence/at91_ether.c b/drivers/net/ethernet/cadence/at91_ether.c
index cf0cf06..e7a476c 100644
--- a/drivers/net/ethernet/cadence/at91_ether.c
+++ b/drivers/net/ethernet/cadence/at91_ether.c
@@ -6,11 +6,6 @@
  * Based on an earlier Atmel EMAC macrocell driver by Atmel and Lineo Inc.
  * Initial version by Rick Bronson 01/11/2003
  *
- * Intel LXT971A PHY support by Christopher Bahns & David Knickerbocker
- *   (Polaroid Corporation)
- *
- * Realtek RTL8201(B)L PHY support by Roman Avramenko <roman@imsystems.ru>
- *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
@@ -38,22 +33,17 @@
 
 #include "macb.h"
 
-#define DRV_NAME	"at91_ether"
-#define DRV_VERSION	"1.0"
-
 /* 1518 rounded up */
 #define MAX_RBUFF_SZ	0x600
 /* max number of receive buffers */
 #define MAX_RX_DESCR	9
 
-/*
- * Initialize and start the Receiver and Transmit subsystems
- */
+/* Initialize and start the Receiver and Transmit subsystems */
 static int at91ether_start(struct net_device *dev)
 {
 	struct macb *lp = netdev_priv(dev);
-	unsigned long ctl;
 	dma_addr_t addr;
+	u32 ctl;
 	int i;
 
 	lp->rx_ring = dma_alloc_coherent(&lp->pdev->dev,
@@ -100,13 +90,11 @@ static int at91ether_start(struct net_device *dev)
 	return 0;
 }
 
-/*
- * Open the ethernet interface
- */
+/* Open the ethernet interface */
 static int at91ether_open(struct net_device *dev)
 {
 	struct macb *lp = netdev_priv(dev);
-	unsigned long ctl;
+	u32 ctl;
 	int ret;
 
 	if (!is_valid_ether_addr(dev->dev_addr))
@@ -123,9 +111,13 @@ static int at91ether_open(struct net_device *dev)
 		return ret;
 
 	/* Enable MAC interrupts */
-	macb_writel(lp, IER, MACB_BIT(RCOMP) | MACB_BIT(RXUBR)
-				| MACB_BIT(ISR_TUND) | MACB_BIT(ISR_RLE) | MACB_BIT(TCOMP)
-				| MACB_BIT(ISR_ROVR) | MACB_BIT(HRESP));
+	macb_writel(lp, IER, MACB_BIT(RCOMP)	|
+			     MACB_BIT(RXUBR)	|
+			     MACB_BIT(ISR_TUND)	|
+			     MACB_BIT(ISR_RLE)	|
+			     MACB_BIT(TCOMP)	|
+			     MACB_BIT(ISR_ROVR)	|
+			     MACB_BIT(HRESP));
 
 	/* schedule a link state check */
 	phy_start(lp->phy_dev);
@@ -135,23 +127,24 @@ static int at91ether_open(struct net_device *dev)
 	return 0;
 }
 
-/*
- * Close the interface
- */
+/* Close the interface */
 static int at91ether_close(struct net_device *dev)
 {
 	struct macb *lp = netdev_priv(dev);
-	unsigned long ctl;
+	u32 ctl;
 
 	/* Disable Receiver and Transmitter */
 	ctl = macb_readl(lp, NCR);
 	macb_writel(lp, NCR, ctl & ~(MACB_BIT(TE) | MACB_BIT(RE)));
 
 	/* Disable MAC interrupts */
-	macb_writel(lp, IDR, MACB_BIT(RCOMP) | MACB_BIT(RXUBR)
-				| MACB_BIT(ISR_TUND) | MACB_BIT(ISR_RLE)
-				| MACB_BIT(TCOMP) | MACB_BIT(ISR_ROVR)
-				| MACB_BIT(HRESP));
+	macb_writel(lp, IDR, MACB_BIT(RCOMP)	|
+			     MACB_BIT(RXUBR)	|
+			     MACB_BIT(ISR_TUND)	|
+			     MACB_BIT(ISR_RLE)	|
+			     MACB_BIT(TCOMP)	|
+			     MACB_BIT(ISR_ROVR) |
+			     MACB_BIT(HRESP));
 
 	netif_stop_queue(dev);
 
@@ -168,9 +161,7 @@ static int at91ether_close(struct net_device *dev)
 	return 0;
 }
 
-/*
- * Transmit packet.
- */
+/* Transmit packet */
 static int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct macb *lp = netdev_priv(dev);
@@ -181,7 +172,8 @@ static int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		/* Store packet information (to free when Tx completed) */
 		lp->skb = skb;
 		lp->skb_length = skb->len;
-		lp->skb_physaddr = dma_map_single(NULL, skb->data, skb->len, DMA_TO_DEVICE);
+		lp->skb_physaddr = dma_map_single(NULL, skb->data, skb->len,
+							DMA_TO_DEVICE);
 
 		/* Set address of the data in the Transmit Address register */
 		macb_writel(lp, TAR, lp->skb_physaddr);
@@ -190,16 +182,13 @@ static int at91ether_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	} else {
 		netdev_err(dev, "%s called, but device is busy!\n", __func__);
-		return NETDEV_TX_BUSY;	/* if we return anything but zero, dev.c:1055 calls kfree_skb(skb)
-				on this skb, he also reports -ENETDOWN and printk's, so either
-				we free and return(0) or don't free and return 1 */
+		return NETDEV_TX_BUSY;
 	}
 
 	return NETDEV_TX_OK;
 }
 
-/*
- * Extract received frame from buffer descriptors and sent to upper layers.
+/* Extract received frame from buffer descriptors and sent to upper layers.
  * (Called from interrupt context)
  */
 static void at91ether_rx(struct net_device *dev)
@@ -240,24 +229,25 @@ static void at91ether_rx(struct net_device *dev)
 	}
 }
 
-/*
- * MAC interrupt handler
- */
+/* MAC interrupt handler */
 static irqreturn_t at91ether_interrupt(int irq, void *dev_id)
 {
-	struct net_device *dev = (struct net_device *) dev_id;
+	struct net_device *dev = dev_id;
 	struct macb *lp = netdev_priv(dev);
-	unsigned long intstatus, ctl;
+	u32 intstatus, ctl;
 
 	/* MAC Interrupt Status register indicates what interrupts are pending.
-	   It is automatically cleared once read. */
+	 * It is automatically cleared once read.
+	 */
 	intstatus = macb_readl(lp, ISR);
 
-	if (intstatus & MACB_BIT(RCOMP))		/* Receive complete */
+	/* Receive complete */
+	if (intstatus & MACB_BIT(RCOMP))
 		at91ether_rx(dev);
 
-	if (intstatus & MACB_BIT(TCOMP)) {	/* Transmit complete */
-		/* The TCOM bit is set even if the transmission failed. */
+	/* Transmit complete */
+	if (intstatus & MACB_BIT(TCOMP)) {
+		/* The TCOM bit is set even if the transmission failed */
 		if (intstatus & (MACB_BIT(ISR_TUND) | MACB_BIT(ISR_RLE)))
 			lp->stats.tx_errors++;
 
@@ -271,7 +261,7 @@ static irqreturn_t at91ether_interrupt(int irq, void *dev_id)
 		netif_wake_queue(dev);
 	}
 
-	/* Work-around for Errata #11 */
+	/* Work-around for EMAC Errata section 41.3.1 */
 	if (intstatus & MACB_BIT(RXUBR)) {
 		ctl = macb_readl(lp, NCR);
 		macb_writel(lp, NCR, ctl & ~MACB_BIT(RE));
@@ -354,18 +344,17 @@ static int at91ether_get_hwaddr_dt(struct macb *bp)
 }
 #endif
 
-/*
- * Detect MAC & PHY and perform ethernet interface initialization
- */
+/* Detect MAC & PHY and perform ethernet interface initialization */
 static int __init at91ether_probe(struct platform_device *pdev)
 {
 	struct macb_platform_data *board_data = pdev->dev.platform_data;
 	struct resource *regs;
 	struct net_device *dev;
 	struct phy_device *phydev;
+	struct pinctrl *pinctrl;
 	struct macb *lp;
 	int res;
-	struct pinctrl *pinctrl;
+	u32 reg;
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!regs)
@@ -389,7 +378,8 @@ static int __init at91ether_probe(struct platform_device *pdev)
 	lp->dev = dev;
 	spin_lock_init(&lp->lock);
 
-	dev->base_addr = regs->start;		/* physical base address */
+	/* physical base address */
+	dev->base_addr = regs->start;
 	lp->regs = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));
 	if (!lp->regs) {
 		res = -ENOMEM;
@@ -432,10 +422,11 @@ static int __init at91ether_probe(struct platform_device *pdev)
 
 	macb_writel(lp, NCR, 0);
 
+	reg = MACB_BF(CLK, MACB_CLK_DIV32) | MACB_BIT(BIG);
 	if (lp->phy_interface == PHY_INTERFACE_MODE_RMII)
-		macb_writel(lp, NCFGR, MACB_BF(CLK, MACB_CLK_DIV32) | MACB_BIT(BIG) | MACB_BIT(RM9200_RMII));
-	else
-		macb_writel(lp, NCFGR, MACB_BF(CLK, MACB_CLK_DIV32) | MACB_BIT(BIG));
+		reg |= MACB_BIT(RM9200_RMII);
+
+	macb_writel(lp, NCFGR, reg);
 
 	/* Register the network interface */
 	res = register_netdev(dev);
@@ -445,11 +436,13 @@ static int __init at91ether_probe(struct platform_device *pdev)
 	if (macb_mii_init(lp) != 0)
 		goto err_out_unregister_netdev;
 
-	netif_carrier_off(dev);		/* will be enabled in open() */
+	/* will be enabled in open() */
+	netif_carrier_off(dev);
 
 	phydev = lp->phy_dev;
 	netdev_info(dev, "attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
-				phydev->drv->name, dev_name(&phydev->dev), phydev->irq);
+				phydev->drv->name, dev_name(&phydev->dev),
+				phydev->irq);
 
 	/* Display ethernet banner */
 	netdev_info(dev, "AT91 ethernet at 0x%08lx int=%d (%pM)\n",
@@ -486,7 +479,6 @@ static int __devexit at91ether_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-
 static int at91ether_suspend(struct platform_device *pdev, pm_message_t mesg)
 {
 	struct net_device *net_dev = platform_get_drvdata(pdev);
@@ -514,7 +506,6 @@ static int at91ether_resume(struct platform_device *pdev)
 	}
 	return 0;
 }
-
 #else
 #define at91ether_suspend	NULL
 #define at91ether_resume	NULL
@@ -525,7 +516,7 @@ static struct platform_driver at91ether_driver = {
 	.suspend	= at91ether_suspend,
 	.resume		= at91ether_resume,
 	.driver		= {
-		.name	= DRV_NAME,
+		.name	= "at91_ether",
 		.owner	= THIS_MODULE,
 		.of_match_table	= of_match_ptr(at91ether_dt_ids),
 	},
@@ -547,4 +538,4 @@ module_exit(at91ether_exit)
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("AT91RM9200 EMAC Ethernet driver");
 MODULE_AUTHOR("Andrew Victor");
-MODULE_ALIAS("platform:" DRV_NAME);
+MODULE_ALIAS("platform:at91_ether");
-- 
1.7.10.4

