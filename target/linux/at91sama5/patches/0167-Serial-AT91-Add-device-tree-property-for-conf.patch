From 164960f693cf347be888ad1180be3e64e9a2d6b2 Mon Sep 17 00:00:00 2001
From: Elen Song <elen.song@atmel.com>
Date: Thu, 22 Nov 2012 10:28:01 +0800
Subject: [PATCH 167/319] Serial: AT91: Add device tree property for conf

Configuration option is now handled by the dma device tree property
that links to the corresponding DMA controller.

Signed-off-by: Elen Song <elen.song@atmel.com>
---
 drivers/tty/serial/atmel_serial.c |  204 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 203 insertions(+), 1 deletion(-)

diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c
index f853882..8dc3229 100644
--- a/drivers/tty/serial/atmel_serial.c
+++ b/drivers/tty/serial/atmel_serial.c
@@ -177,6 +177,182 @@ static const struct of_device_id atmel_serial_dt_ids[] = {
 };
 
 MODULE_DEVICE_TABLE(of, atmel_serial_dt_ids);
+
+static int atmel_uart_rx_dma_of_init(struct device_node *np,
+					struct at_dma_slave *atslave)
+{
+	struct of_phandle_args  dma_spec;
+	struct device_node      *dmac_np;
+	struct platform_device  *dmac_pdev;
+	const __be32            *nbcells;
+	int                     ret;
+
+	ret = of_parse_phandle_with_args(np,
+					"dma-rx",
+					"#dma-cells",
+					0,
+					&dma_spec);
+	if (ret || !dma_spec.np) {
+		pr_err("%s: can't parse dma property (%d)\n",
+							np->full_name,
+							ret);
+		goto err0;
+	}
+	dmac_np = dma_spec.np;
+
+	/* check property format */
+	nbcells = of_get_property(dmac_np, "#dma-cells", NULL);
+	if (!nbcells) {
+		pr_err("%s: #dma-cells property is required\n", np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	if (dma_spec.args_count != be32_to_cpup(nbcells)
+		|| dma_spec.args_count != 1) {
+		pr_err("%s: wrong #dma-cells for %s\n",
+			np->full_name, dmac_np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+	/* retreive DMA controller information */
+	dmac_pdev = of_find_device_by_node(dmac_np);
+	if (!dmac_pdev) {
+		pr_err("%s: unable to find pdev from DMA controller\n",
+			dmac_np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	/* now fill in the at_dma_slave structure */
+	atslave->dma_dev = &dmac_pdev->dev;
+	atslave->cfg = dma_spec.args[0];
+
+	atslave->reg_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+
+	return ret;
+err1:
+	of_node_put(dma_spec.np);
+err0:
+	pr_debug("%s exited with status %d\n", __func__, ret);
+	return ret;
+}
+
+static int atmel_uart_tx_dma_of_init(struct device_node *np,
+					struct at_dma_slave *atslave)
+{
+	struct of_phandle_args  dma_spec;
+	struct device_node      *dmac_np;
+	struct platform_device  *dmac_pdev;
+	const __be32            *nbcells;
+	int                     ret;
+
+	ret = of_parse_phandle_with_args(np,
+					"dma-tx",
+					"#dma-cells",
+					0,
+					&dma_spec);
+	if (ret || !dma_spec.np) {
+		pr_err("%s: can't parse dma property (%d)\n",
+							np->full_name,
+							ret);
+		goto err0;
+	}
+	dmac_np = dma_spec.np;
+
+	/* check property format */
+	nbcells = of_get_property(dmac_np, "#dma-cells", NULL);
+	if (!nbcells) {
+		pr_err("%s: #dma-cells property is required\n", np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	if (dma_spec.args_count != be32_to_cpup(nbcells)
+		|| dma_spec.args_count != 1) {
+		pr_err("%s: wrong #dma-cells for %s\n",
+			np->full_name, dmac_np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+	/* retreive DMA controller information */
+	dmac_pdev = of_find_device_by_node(dmac_np);
+	if (!dmac_pdev) {
+		pr_err("%s: unable to find pdev from DMA controller\n",
+			dmac_np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	/* now fill in the at_dma_slave structure */
+	atslave->dma_dev = &dmac_pdev->dev;
+	atslave->cfg = dma_spec.args[0];
+
+	atslave->reg_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
+
+	return ret;
+err1:
+	of_node_put(dma_spec.np);
+err0:
+	pr_debug("%s exited with status %d\n", __func__, ret);
+	return ret;
+}
+
+static struct atmel_uart_data __devinit*
+atmel_uart_of_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct atmel_uart_data *pdata;
+
+	if (!np) {
+		dev_err(&pdev->dev, "device node not found\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata) {
+		dev_err(&pdev->dev, "could not allocate memory for pdata\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	pdata->dma_rx_slave = devm_kzalloc(&pdev->dev,
+					sizeof(*(pdata->dma_rx_slave)),
+					GFP_KERNEL);
+	if (!pdata->dma_rx_slave) {
+		dev_err(&pdev->dev, "could not allocate memory for dma_rx_slave\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	pdata->dma_tx_slave = devm_kzalloc(&pdev->dev,
+					sizeof(*(pdata->dma_tx_slave)),
+					GFP_KERNEL);
+	if (!pdata->dma_tx_slave) {
+		dev_err(&pdev->dev, "could not allocate memory for dma_tx_slave\n");
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return pdata;
+}
+
+#else /* CONFIG_OF */
+
+static int atmel_uart_rx_dma_of_init(struct device_node *np,
+					struct at_dma_slave *atslave)
+{
+	return ERR_PTR(-EINVAL);
+}
+
+static int atmel_uart_tx_dma_of_init(struct device_node *np,
+					struct at_dma_slave *atslave)
+{
+	return ERR_PTR(-EINVAL);
+}
+
+static struct atmel_uart_data __devinit*
+atmel_uart_of_init(struct platform_device *pdev)
+{
+	return ERR_PTR(-EINVAL);
+}
 #endif
 
 static inline struct atmel_uart_port *
@@ -1480,10 +1656,26 @@ static void __devinit atmel_init_port(struct atmel_uart_port *atmel_port,
 				      struct platform_device *pdev)
 {
 	struct uart_port *port = &atmel_port->uart;
-	struct atmel_uart_data *pdata = pdev->dev.platform_data;
+	struct atmel_uart_data *pdata = port->private_data;
 
 	if (pdev->dev.of_node) {
 		atmel_of_init_port(atmel_port, pdev->dev.of_node);
+		if (atmel_port->use_dma_rx) {
+			/* retrive DMA configuration first */
+			if (atmel_uart_rx_dma_of_init(pdev->dev.of_node,
+							pdata->dma_rx_slave)) {
+				dev_err(&pdev->dev, "could not find DMA rx parameters\n");
+				devm_kfree(&pdev->dev, pdata->dma_rx_slave);
+			}
+		}
+		if (atmel_port->use_dma_tx) {
+			/* retrive DMA configuration first */
+			if (atmel_uart_tx_dma_of_init(pdev->dev.of_node,
+							pdata->dma_tx_slave)) {
+				dev_err(&pdev->dev, "could not find DMA tx parameters\n");
+				devm_kfree(&pdev->dev, pdata->dma_tx_slave);
+			}
+		}
 	} else {
 		atmel_port->use_dma_rx	= pdata->use_dma_rx;
 		atmel_port->use_dma_tx	= pdata->use_dma_tx;
@@ -1793,6 +1985,15 @@ static int __devinit atmel_serial_probe(struct platform_device *pdev)
 	int ret = -ENODEV;
 	struct pinctrl *pinctrl;
 
+	if (!pdata) {
+		pdata = atmel_uart_of_init(pdev);
+		if (IS_ERR(pdata)) {
+			dev_err(&pdev->dev, "platform data not available\n");
+			ret = PTR_ERR(pdata);
+			goto err;
+		}
+	}
+
 	BUILD_BUG_ON(ATMEL_SERIAL_RINGSIZE & (ATMEL_SERIAL_RINGSIZE - 1));
 
 	if (np)
@@ -1821,6 +2022,7 @@ static int __devinit atmel_serial_probe(struct platform_device *pdev)
 	port = &atmel_ports[ret];
 	port->backup_imr = 0;
 	port->uart.line = ret;
+	port->uart.private_data = pdata;
 
 	atmel_init_port(port, pdev);
 
-- 
1.7.10.4

