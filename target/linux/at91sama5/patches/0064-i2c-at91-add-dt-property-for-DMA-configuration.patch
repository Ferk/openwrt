From 42f0c1cb027a859e562256857ebeea4811a65223 Mon Sep 17 00:00:00 2001
From: Ludovic Desroches <ludovic.desroches@atmel.com>
Date: Thu, 15 Nov 2012 18:41:48 +0100
Subject: [PATCH 064/319] i2c: at91: add dt property for DMA configuration

i2c: at91: add dt property for DMA configuration

Signed-off-by: Ludovic Desroches <ludovic.desroches@atmel.com>
---
 drivers/i2c/busses/i2c-at91.c |   56 ++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 55 insertions(+), 1 deletion(-)

diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c
index bdf07b9..2f61ce2 100644
--- a/drivers/i2c/busses/i2c-at91.c
+++ b/drivers/i2c/busses/i2c-at91.c
@@ -583,6 +583,55 @@ static const struct platform_device_id at91_twi_devtypes[] = {
 };
 
 #if defined(CONFIG_OF)
+static int at91_twi_of_init(struct device_node *np, struct at_dma_slave *atslave)
+{
+	struct of_phandle_args  dma_spec;
+	struct device_node      *dmac_np;
+	struct platform_device  *dmac_pdev;
+	const __be32            *nbcells;
+	int                     ret;
+
+	ret = of_parse_phandle_with_args(np, "dma", "#dma-cells", 0, &dma_spec);
+	if (ret || !dma_spec.np) {
+		pr_err("%s: can't parse dma property (%d)\n", np->full_name, ret);
+		goto err0;
+	}
+	dmac_np = dma_spec.np;
+
+	/* check property format */
+	nbcells = of_get_property(dmac_np, "#dma-cells", NULL);
+	if (!nbcells) {
+		pr_err("%s: #dma-cells property is required\n", np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	if (dma_spec.args_count != be32_to_cpup(nbcells)
+			|| dma_spec.args_count != 1) {
+		pr_err("%s: wrong #dma-cells for %s\n",
+				np->full_name, dmac_np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	dmac_pdev = of_find_device_by_node(dmac_np);
+	if (!dmac_pdev) {
+		pr_err("%s: unable to find pdev from DMA controller\n",
+				dmac_np->full_name);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	atslave->dma_dev = &dmac_pdev->dev;
+	atslave->cfg = dma_spec.args[0];
+
+err1:
+	of_node_put(dma_spec.np);
+err0:
+	pr_debug("%s exited with status %d\n", __func__, ret);
+	return ret;
+}
+
 static const struct of_device_id atmel_twi_dt_ids[] = {
 	{
 		.compatible = "atmel,at91sam9260-i2c",
@@ -602,6 +651,10 @@ static const struct of_device_id atmel_twi_dt_ids[] = {
 };
 MODULE_DEVICE_TABLE(of, atmel_twi_dt_ids);
 #else
+static int at91_twi_of_init(struct device_node *np, struct at_dma_slave *atslave)
+{
+	return -ENODEV;
+}
 #define atmel_twi_dt_ids NULL
 #endif
 
@@ -756,7 +809,8 @@ static int __devinit at91_twi_probe(struct platform_device *pdev)
 	clk_prepare_enable(dev->clk);
 
 	if (dev->pdata->has_dma_support) {
-		if (at91_twi_configure_dma(dev, phy_addr) == 0)
+		if ( at91_twi_of_init(pdev->dev.of_node, &dev->pdata->dma_slave) == 0
+		     && at91_twi_configure_dma(dev, phy_addr) == 0)
 			dev->use_dma = true;
 	}
 
-- 
1.7.10.4

