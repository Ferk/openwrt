From 6e4acde2b1cac1b91222f25065d76c0b57c35047 Mon Sep 17 00:00:00 2001
From: Wenyou Yang <wenyou.yang@atmel.com>
Date: Mon, 3 Dec 2012 12:39:12 +0800
Subject: [PATCH 156/319] watchdog/at91sam9_wdt: Remove the global variable
 at91wdt_private

Remove the global variable at91wdt_private
and add the struct at91wdt_drvdata as driver data

Signed-off-by: Wenyou Yang <wenyou.yang@atmel.com>
---
 drivers/watchdog/at91sam9_wdt.c |   64 +++++++++++++++++++++++++--------------
 1 file changed, 41 insertions(+), 23 deletions(-)

diff --git a/drivers/watchdog/at91sam9_wdt.c b/drivers/watchdog/at91sam9_wdt.c
index 8197a67..6f21ca8 100644
--- a/drivers/watchdog/at91sam9_wdt.c
+++ b/drivers/watchdog/at91sam9_wdt.c
@@ -35,11 +35,6 @@
 
 #define DRV_NAME "AT91SAM9 Watchdog"
 
-#define wdt_read(field) \
-	__raw_readl(at91wdt_private.base + field)
-#define wdt_write(field, val) \
-	__raw_writel((val), at91wdt_private.base + field)
-
 /* AT91SAM9 watchdog runs a 12bit counter @ 256Hz,
  * use this to convert a watchdog
  * value from/to milliseconds.
@@ -69,23 +64,33 @@ MODULE_PARM_DESC(nowayout, "Watchdog cannot be stopped once started "
 
 static void at91_ping(unsigned long data);
 
-static struct {
-	void __iomem *base;
-	unsigned long next_heartbeat;	/* the next_heartbeat for the timer */
-	unsigned long open;
-	char expect_close;
-	struct timer_list timer;	/* The timer that pings the watchdog */
-} at91wdt_private;
+struct at91wdt_drvdata {
+	void __iomem	*phybase;
+	bool		is_enable;	/* indicate if the watchdog is eabled */
+	unsigned long	next_heartbeat;	/* the next_heartbeat for the timer */
+	struct timer_list	timer;	/* The timer that pings the watchdog */
+};
 
 /* ......................................................................... */
 
+static inline unsigned int wdt_read(struct at91wdt_drvdata *driver_data,
+					unsigned int field)
+{
+	return readl_relaxed(driver_data->phybase + field);
+}
+
+static inline void wdt_write(struct at91wdt_drvdata *driver_data,
+				unsigned int field, unsigned int val)
+{
+	writel_relaxed((val), driver_data->phybase + field);
+}
 
 /*
  * Reload the watchdog timer.  (ie, pat the watchdog)
  */
-static inline void at91_wdt_reset(void)
+static inline void at91_wdt_reset(struct at91wdt_drvdata *driver_data)
 {
-	wdt_write(AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);
+	wdt_write(driver_data, AT91_WDT_CR, AT91_WDT_KEY | AT91_WDT_WDRSTT);
 }
 
 /*
@@ -93,10 +98,12 @@ static inline void at91_wdt_reset(void)
  */
 static void at91_ping(unsigned long data)
 {
-	if (time_before(jiffies, at91wdt_private.next_heartbeat) ||
-			(!nowayout && !at91wdt_private.open)) {
-		at91_wdt_reset();
-		mod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);
+	struct watchdog_device *wddev = (struct watchdog_device *)data;
+	struct at91wdt_drvdata *driver_data = watchdog_get_drvdata(wddev);
+
+	if (time_before(jiffies, driver_data->next_heartbeat)) {
+		at91_wdt_reset(driver_data);
+		mod_timer(&driver_data->timer, jiffies + WDT_TIMEOUT);
 	} else
 		pr_crit("I will reset your machine !\n");
 }
@@ -187,14 +194,24 @@ static struct watchdog_device at91wdt_wdd __initdata = {
 
 static int __init at91wdt_probe(struct platform_device *pdev)
 {
+	struct at91wdt_drvdata *driver_data;
 	struct resource	*r;
 	int res;
 
+	driver_data = devm_kzalloc(&pdev->dev,
+				sizeof(*driver_data), GFP_KERNEL);
+	if (!driver_data) {
+		dev_err(&pdev->dev, "Unable to alloacate watchdog device\n");
+		return -ENOMEM;
+	}
+
+	watchdog_set_drvdata(&at91wdt_wdd, driver_data);
+
 	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!r)
 		return -ENODEV;
-	at91wdt_private.base = ioremap(r->start, resource_size(r));
-	if (!at91wdt_private.base) {
+	driver_data->phybase = ioremap(r->start, resource_size(r));
+	if (!driver_data->phybase) {
 		dev_err(&pdev->dev, "failed to map registers, aborting.\n");
 		return -ENOMEM;
 	}
@@ -206,9 +223,10 @@ static int __init at91wdt_probe(struct platform_device *pdev)
 	if (res)
 		return res;
 
-	at91wdt_private.next_heartbeat = jiffies + at91wdt_wdd.timeout * HZ;
-	setup_timer(&at91wdt_private.timer, at91_ping, 0);
-	mod_timer(&at91wdt_private.timer, jiffies + WDT_TIMEOUT);
+	driver_data->next_heartbeat = jiffies + at91wdt_wdd.timeout * HZ;
+	setup_timer(&driver_data->timer, at91_ping,
+					(unsigned long)&at91wdt_wdd);
+	mod_timer(&driver_data->timer, jiffies + WDT_TIMEOUT);
 
 	pr_info("enabled (heartbeat=%d sec, nowayout=%d)\n",
 		at91wdt_wdd.timeout, nowayout);
-- 
1.7.10.4

